<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timeseries Streaming Test Client (GraphQL-style)</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            background: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px 8px 0 0;
        }

        .header h1 {
            margin-bottom: 5px;
        }

        .content {
            padding: 20px;
        }

        .section {
            margin-bottom: 30px;
        }

        .section h2 {
            color: #333;
            margin-bottom: 15px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 5px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
        }

        input[type="text"], textarea, select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        textarea {
            resize: vertical;
            min-height: 80px;
            font-family: monospace;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #5568d3;
        }

        .btn-danger {
            background: #f56565;
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #e53e3e;
        }

        .btn-secondary {
            background: #718096;
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #4a5568;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .status {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-weight: 500;
        }

        .status.disconnected {
            background: #fed7d7;
            color: #742a2a;
        }

        .status.connected {
            background: #c6f6d5;
            color: #22543d;
        }

        .status.connecting {
            background: #feebc8;
            color: #7c2d12;
        }

        .messages {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
            background: #fafafa;
            font-family: monospace;
            font-size: 12px;
        }

        .message {
            padding: 8px;
            margin-bottom: 8px;
            border-radius: 4px;
            border-left: 4px solid;
        }

        .message.connection_ack {
            background: #e6fffa;
            border-left-color: #319795;
        }

        .message.data {
            background: #ebf4ff;
            border-left-color: #3182ce;
        }

        .message.error {
            background: #fff5f5;
            border-left-color: #e53e3e;
        }

        .message.info {
            background: #f7fafc;
            border-left-color: #718096;
        }

        .message-time {
            color: #718096;
            font-size: 11px;
            margin-bottom: 4px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: #f7fafc;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #e2e8f0;
        }

        .stat-label {
            color: #718096;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #2d3748;
            font-size: 24px;
            font-weight: bold;
        }

        .info-box {
            background: #ebf8ff;
            border: 1px solid #90cdf4;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .info-box h3 {
            color: #2c5282;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .info-box ul {
            margin-left: 20px;
            color: #2d3748;
        }

        .info-box li {
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔄 Timeseries Streaming Test Client</h1>
            <p>GraphQL-style WebSocket subscriptions (connection_init protocol)</p>
        </div>

        <div class="content">
            <!-- Info Box -->
            <div class="info-box">
                <h3>GraphQL-style Protocol Flow:</h3>
                <ul>
                    <li>1. Configure subscription settings below</li>
                    <li>2. Click "Connect & Subscribe" - WebSocket connects and immediately sends <code>connection_init</code> message</li>
                    <li>3. Server validates and responds with <code>connection_ack</code> or <code>error</code></li>
                    <li>4. Server streams <code>data</code> messages with measurement updates</li>
                    <li>5. Click "Disconnect" to close the connection</li>
                </ul>
            </div>

            <!-- Connection Status -->
            <div class="section">
                <h2>Connection Status</h2>
                <div id="status" class="status disconnected">
                    ⚫ Disconnected
                </div>
            </div>

            <!-- Statistics -->
            <div class="section">
                <h2>Statistics</h2>
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-label">Messages Received</div>
                        <div class="stat-value" id="stat-messages">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Data Updates</div>
                        <div class="stat-value" id="stat-updates">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Errors</div>
                        <div class="stat-value" id="stat-errors">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Connection Time</div>
                        <div class="stat-value" id="stat-uptime">--</div>
                    </div>
                </div>
            </div>

            <!-- Connection Settings -->
            <div class="section">
                <h2>Endpoint Selection</h2>
                <div class="form-group">
                    <label for="endpoint-mode">Endpoint Mode:</label>
                    <select id="endpoint-mode" onchange="updateEndpointURL()">
                        <option value="simple">Simple (/subscribe)</option>
                        <option value="advanced">Advanced (/subscribe/advanced)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="ws-url">WebSocket URL:</label>
                    <input type="text" id="ws-url" value="ws://localhost:8080/api/v1/measurements/subscribe">
                </div>
            </div>

            <!-- Subscription Settings -->
            <div class="section">
                <h2>Subscription Configuration</h2>

                <!-- Subscription Mode Selector -->
                <div class="form-group">
                    <label for="subscription-mode">Configuration Mode:</label>
                    <select id="subscription-mode" onchange="toggleSubscriptionMode()">
                        <option value="simple">Simple (Sensor Names)</option>
                        <option value="advanced">Advanced (Discovery Filters)</option>
                    </select>
                </div>

                <!-- Simple Mode Fields -->
                <div id="simple-mode" style="display:block;">
                    <div class="form-group">
                        <label for="sensor-names">Sensor Names (comma-separated):</label>
                        <input type="text" id="sensor-names" placeholder="e.g., HUM_Park_067, PARK_Highway_052" value="HUM_Park_067">
                    </div>
                    <div class="form-group">
                        <label for="type-names">Type Names (comma-separated, optional):</label>
                        <input type="text" id="type-names" placeholder="e.g., temperature, humidity">
                    </div>
                </div>

                <!-- Discovery Mode Fields -->
                <div id="discovery-mode" style="display:none;">
                    <div class="form-group">
                        <label for="required-types">Required Types (comma-separated):</label>
                        <input type="text" id="required-types" placeholder="e.g., temperature, humidity" value="power_generation">
                        <small style="color: #718096;">Sensors must have ALL of these types</small>
                    </div>
                    <div class="form-group">
                        <label for="optional-types">Optional Types (comma-separated):</label>
                        <input type="text" id="optional-types" placeholder="e.g., pressure">
                        <small style="color: #718096;">Sensors may have ANY of these types</small>
                    </div>
                    <div class="form-group">
                        <label for="dataset-ids">Dataset IDs (comma-separated):</label>
                        <input type="text" id="dataset-ids" placeholder="e.g., weather_stations">
                    </div>
                    <div class="form-group">
                        <label for="measurement-expression">Measurement Filter Expression:</label>
                        <input type="text" id="measurement-expression" placeholder="e.g., temperature.gteq.20">
                        <small style="color: #718096;">Examples: temperature.gteq.20, or(temp.gt.30, humidity.lt.40)</small>
                    </div>
                    <div class="form-group">
                        <label for="latest-only">
                            <input type="checkbox" id="latest-only" style="width: auto; display: inline;" checked>
                            Latest Only
                        </label>
                    </div>
                    <div class="form-group">
                        <label for="discovery-limit">Limit (max sensors):</label>
                        <input type="text" id="discovery-limit" placeholder="e.g., 50" value="10">
                    </div>
                </div>

                <div class="button-group">
                    <button class="btn-primary" id="btn-connect" onclick="connect()">Connect & Subscribe</button>
                    <button class="btn-danger" id="btn-disconnect" onclick="disconnect()" disabled>Disconnect</button>
                </div>
            </div>

            <!-- Custom Message -->
            <div class="section">
                <h2>Custom connection_init Payload</h2>
                <div class="form-group">
                    <label for="custom-endpoint">Endpoint for Custom Payload:</label>
                    <select id="custom-endpoint">
                        <option value="simple">Simple (/subscribe)</option>
                        <option value="advanced">Advanced (/subscribe/advanced)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="custom-message">JSON Payload (connection_init will be sent automatically):</label>
                    <textarea id="custom-message" placeholder='{"sensor_names": ["sensor1"], "type_names": ["temperature"]}'></textarea>
                </div>
                <div class="form-group">
                    <label>Quick Examples:</label>
                    <div class="button-group">
                        <button class="btn-secondary" onclick="loadExample('simple')">Simple</button>
                        <button class="btn-secondary" onclick="loadExample('discovery')">Discovery</button>
                        <button class="btn-secondary" onclick="loadExample('discovery-filter')">Discovery + Filter</button>
                    </div>
                    <div class="button-group">
                        <button class="btn-secondary" onclick="loadExample('geoposition-bbox')">Geoposition Bbox</button>
                        <button class="btn-secondary" onclick="loadExample('geoshape-bbox')">Geoshape Bbox</button>
                        <button class="btn-secondary" onclick="loadExample('geoposition-radius')">Geoposition Radius</button>
                    </div>
                </div>
                <div class="button-group">
                    <button class="btn-primary" id="btn-custom-connect" onclick="connectWithCustomPayload()">Connect with Custom Payload</button>
                </div>
            </div>

            <!-- Messages Log -->
            <div class="section">
                <h2>Messages Log</h2>
                <div class="button-group" style="margin-bottom: 15px;">
                    <button class="btn-secondary" onclick="clearMessages()">Clear Log</button>
                </div>
                <div id="messages" class="messages">
                    <div class="message info">
                        <div class="message-time">Ready</div>
                        Configure subscription settings above and click "Connect & Subscribe"
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let ws = null;
        let stats = {
            messages: 0,
            updates: 0,
            errors: 0,
            connectTime: null
        };
        let uptimeInterval = null;

        function updateEndpointURL() {
            const mode = document.getElementById('endpoint-mode').value;
            const baseURL = 'ws://localhost:8080/api/v1/measurements/subscribe';
            document.getElementById('ws-url').value = mode === 'advanced' ? baseURL + '/advanced' : baseURL;
        }

        function toggleSubscriptionMode() {
            const mode = document.getElementById('subscription-mode').value;
            document.getElementById('simple-mode').style.display = mode === 'simple' ? 'block' : 'none';
            document.getElementById('discovery-mode').style.display = mode === 'advanced' ? 'block' : 'none';

            // Also update endpoint mode to match
            document.getElementById('endpoint-mode').value = mode;
            updateEndpointURL();
        }

        function updateStatus(status, text) {
            const statusEl = document.getElementById('status');
            statusEl.className = `status ${status}`;
            statusEl.textContent = text;
        }

        function updateStats() {
            document.getElementById('stat-messages').textContent = stats.messages;
            document.getElementById('stat-updates').textContent = stats.updates;
            document.getElementById('stat-errors').textContent = stats.errors;

            if (stats.connectTime) {
                const seconds = Math.floor((Date.now() - stats.connectTime) / 1000);
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                document.getElementById('stat-uptime').textContent = `${mins}m ${secs}s`;
            } else {
                document.getElementById('stat-uptime').textContent = '--';
            }

            // Update page title with message count for visibility
            document.title = `Streaming Client (${stats.messages} msgs, ${stats.updates} updates)`;
        }

        function addMessage(type, content) {
            console.log(`addMessage called: type=${type}`, content);

            stats.messages++;
            if (type === 'data') stats.updates++;
            if (type === 'error') stats.errors++;
            updateStats();

            const messagesEl = document.getElementById('messages');
            if (!messagesEl) {
                console.error('Messages element not found!');
                return;
            }

            const messageEl = document.createElement('div');
            messageEl.className = `message ${type}`;

            const time = new Date().toLocaleTimeString();
            const timeEl = document.createElement('div');
            timeEl.className = 'message-time';
            timeEl.textContent = time;

            const contentEl = document.createElement('pre');
            contentEl.textContent = typeof content === 'string' ? content : JSON.stringify(content, null, 2);
            contentEl.style.margin = '0';
            contentEl.style.whiteSpace = 'pre-wrap';

            messageEl.appendChild(timeEl);
            messageEl.appendChild(contentEl);
            messagesEl.appendChild(messageEl);

            console.log(`Message added to DOM. Total messages in container: ${messagesEl.children.length}`);

            // Auto-scroll to bottom
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }

        function clearMessages() {
            document.getElementById('messages').innerHTML = '';
        }

        function buildConnectionInitPayload() {
            const mode = document.getElementById('subscription-mode').value;
            const payload = {};

            if (mode === 'simple') {
                // Simple mode: sensor names
                const sensorNames = document.getElementById('sensor-names').value
                    .split(',')
                    .map(s => s.trim())
                    .filter(s => s);

                if (sensorNames.length === 0) {
                    throw new Error('At least one sensor name is required');
                }

                payload.sensor_names = sensorNames;

                const typeNames = document.getElementById('type-names').value
                    .split(',')
                    .map(s => s.trim())
                    .filter(s => s);

                if (typeNames.length > 0) {
                    payload.type_names = typeNames;
                }
            } else {
                // Discovery mode: advanced filters
                const timeseriesFilter = {};
                const measurementFilter = {};
                let hasTimeseriesFilter = false;
                let hasMeasurementFilter = false;

                // Required types
                const requiredTypes = document.getElementById('required-types').value
                    .split(',')
                    .map(s => s.trim())
                    .filter(s => s);
                if (requiredTypes.length > 0) {
                    timeseriesFilter.required_types = requiredTypes;
                    hasTimeseriesFilter = true;
                }

                // Optional types
                const optionalTypes = document.getElementById('optional-types').value
                    .split(',')
                    .map(s => s.trim())
                    .filter(s => s);
                if (optionalTypes.length > 0) {
                    timeseriesFilter.optional_types = optionalTypes;
                    hasTimeseriesFilter = true;
                }

                // Dataset IDs
                const datasetIds = document.getElementById('dataset-ids').value
                    .split(',')
                    .map(s => s.trim())
                    .filter(s => s);
                if (datasetIds.length > 0) {
                    timeseriesFilter.dataset_ids = datasetIds;
                    hasTimeseriesFilter = true;
                }

                // Measurement expression
                const expression = document.getElementById('measurement-expression').value.trim();
                if (expression) {
                    measurementFilter.expression = expression;
                    hasMeasurementFilter = true;
                }

                // Latest only
                const latestOnly = document.getElementById('latest-only').checked;
                if (latestOnly) {
                    measurementFilter.latest_only = true;
                    hasMeasurementFilter = true;
                }

                if (hasTimeseriesFilter) {
                    payload.timeseries_filter = timeseriesFilter;
                }

                if (hasMeasurementFilter) {
                    payload.measurement_filter = measurementFilter;
                }

                // Limit
                const limit = parseInt(document.getElementById('discovery-limit').value);
                if (!isNaN(limit) && limit > 0) {
                    payload.limit = limit;
                }

                if (!hasTimeseriesFilter && !hasMeasurementFilter) {
                    throw new Error('At least one discovery filter is required (timeseries_filter or measurement_filter)');
                }
            }

            return payload;
        }

        function connect() {
            const url = document.getElementById('ws-url').value;

            if (ws && ws.readyState === WebSocket.OPEN) {
                addMessage('error', 'Already connected');
                return;
            }

            let payload;
            try {
                payload = buildConnectionInitPayload();
            } catch (e) {
                addMessage('error', e.message);
                return;
            }

            updateStatus('connecting', '🟡 Connecting...');
            addMessage('info', `Connecting to ${url}`);

            ws = new WebSocket(url);

            ws.onopen = () => {
                // Send connection_init message immediately
                const initMessage = {
                    type: 'connection_init',
                    payload: payload
                };

                ws.send(JSON.stringify(initMessage));
                addMessage('info', `Sent connection_init: ${JSON.stringify(initMessage, null, 2)}`);

                stats.connectTime = Date.now();
                updateStats();

                // Start uptime counter
                if (uptimeInterval) clearInterval(uptimeInterval);
                uptimeInterval = setInterval(updateStats, 1000);

                // Update button states
                document.getElementById('btn-connect').disabled = true;
                document.getElementById('btn-custom-connect').disabled = true;
                document.getElementById('btn-disconnect').disabled = false;
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    console.log('📨 WebSocket message received:', data);

                    if (data.type === 'connection_ack') {
                        console.log('✅ Connection acknowledged');
                        updateStatus('connected', '🟢 Connected & Subscribed');
                        addMessage('connection_ack', data);
                    } else if (data.type === 'data') {
                        console.log('📊 Data message:', data.payload);
                        addMessage('data', data);
                    } else if (data.type === 'error') {
                        console.error('❌ Error message:', data.payload);
                        addMessage('error', data);
                        // Close connection on error
                        ws.close();
                    } else {
                        console.log('ℹ️ Unknown message type:', data.type);
                        addMessage('info', data);
                    }
                } catch (e) {
                    console.error('⚠️ Failed to parse message:', e, event.data);
                    addMessage('error', `Failed to parse message: ${e.message}`);
                }
            };

            ws.onerror = (error) => {
                addMessage('error', `WebSocket error: ${error}`);
            };

            ws.onclose = () => {
                updateStatus('disconnected', '⚫ Disconnected');
                addMessage('info', 'WebSocket connection closed');
                stats.connectTime = null;
                if (uptimeInterval) {
                    clearInterval(uptimeInterval);
                    uptimeInterval = null;
                }
                updateStats();

                // Update button states
                document.getElementById('btn-connect').disabled = false;
                document.getElementById('btn-custom-connect').disabled = false;
                document.getElementById('btn-disconnect').disabled = true;
            };
        }

        function connectWithCustomPayload() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                addMessage('error', 'Already connected');
                return;
            }

            let customPayload;
            try {
                const payloadText = document.getElementById('custom-message').value;
                customPayload = JSON.parse(payloadText);
            } catch (e) {
                addMessage('error', `Invalid JSON payload: ${e.message}`);
                return;
            }

            // Build URL based on selected endpoint
            const endpointMode = document.getElementById('custom-endpoint').value;
            const baseURL = 'ws://localhost:8080/api/v1/measurements/subscribe';
            const url = endpointMode === 'advanced' ? baseURL + '/advanced' : baseURL;

            updateStatus('connecting', '🟡 Connecting...');
            addMessage('info', `Connecting to ${url} with custom payload`);

            ws = new WebSocket(url);

            ws.onopen = () => {
                // Send connection_init message immediately
                const initMessage = {
                    type: 'connection_init',
                    payload: customPayload
                };

                ws.send(JSON.stringify(initMessage));
                addMessage('info', `Sent connection_init: ${JSON.stringify(initMessage, null, 2)}`);

                stats.connectTime = Date.now();
                updateStats();

                // Start uptime counter
                if (uptimeInterval) clearInterval(uptimeInterval);
                uptimeInterval = setInterval(updateStats, 1000);

                // Update button states
                document.getElementById('btn-connect').disabled = true;
                document.getElementById('btn-custom-connect').disabled = true;
                document.getElementById('btn-disconnect').disabled = false;
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    console.log('📨 WebSocket message received:', data);

                    if (data.type === 'connection_ack') {
                        console.log('✅ Connection acknowledged');
                        updateStatus('connected', '🟢 Connected & Subscribed');
                        addMessage('connection_ack', data);
                    } else if (data.type === 'data') {
                        console.log('📊 Data message:', data.payload);
                        addMessage('data', data);
                    } else if (data.type === 'error') {
                        console.error('❌ Error message:', data.payload);
                        addMessage('error', data);
                        // Close connection on error
                        ws.close();
                    } else {
                        console.log('ℹ️ Unknown message type:', data.type);
                        addMessage('info', data);
                    }
                } catch (e) {
                    console.error('⚠️ Failed to parse message:', e, event.data);
                    addMessage('error', `Failed to parse message: ${e.message}`);
                }
            };

            ws.onerror = (error) => {
                addMessage('error', `WebSocket error: ${error}`);
            };

            ws.onclose = () => {
                updateStatus('disconnected', '⚫ Disconnected');
                addMessage('info', 'WebSocket connection closed');
                stats.connectTime = null;
                if (uptimeInterval) {
                    clearInterval(uptimeInterval);
                    uptimeInterval = null;
                }
                updateStats();

                // Update button states
                document.getElementById('btn-connect').disabled = false;
                document.getElementById('btn-custom-connect').disabled = false;
                document.getElementById('btn-disconnect').disabled = true;
            };
        }

        function disconnect() {
            if (ws) {
                ws.close();
                ws = null;
            }
        }

        function loadExample(type) {
            const examples = {
                'simple': {
                    payload: {
                        "sensor_names": ["HUM_Park_067", "PARK_Highway_052"]
                    },
                    endpoint: 'simple'
                },
                'discovery': {
                    payload: {
                        "timeseries_filter": {
                            "required_types": ["power_generation"]
                        },
                        "limit": 10
                    },
                    endpoint: 'advanced'
                },
                'discovery-filter': {
                    payload: {
                        "timeseries_filter": {
                            "required_types": ["power_generation"]
                        },
                        "measurement_filter": {
                            "latest_only": true,
                            "expression": "power_generation.gteq.100"
                        },
                        "limit": 10
                    },
                    endpoint: 'advanced'
                },
                'geoposition-bbox': {
                    payload: {
                        "timeseries_filter": {
                            "required_types": ["location"]
                        },
                        "measurement_filter": {
                            "expression": "location.bbi.(11.6,46.4,11.65,46.5)",
                            "latest_only": true
                        },
                        "limit": 10
                    },
                    endpoint: 'advanced'
                },
                'geoshape-bbox': {
                    payload: {
                        "timeseries_filter": {
                            "required_types": ["coverage_area"]
                        },
                        "measurement_filter": {
                            "expression": "coverage_area.bbi.(11.0,46.0,12.0,47.0)",
                            "latest_only": true
                        },
                        "limit": 10
                    },
                    endpoint: 'advanced'
                },
                'geoposition-radius': {
                    payload: {
                        "timeseries_filter": {
                            "required_types": ["location"]
                        },
                        "measurement_filter": {
                            "expression": "location.dlt.(11.354,46.498,5000)",
                            "latest_only": true
                        },
                        "limit": 10
                    },
                    endpoint: 'advanced'
                }
            };

            const example = examples[type];
            if (example) {
                document.getElementById('custom-message').value = JSON.stringify(example.payload, null, 2);
                document.getElementById('custom-endpoint').value = example.endpoint;
                addMessage('info', `Loaded ${type} example (${example.endpoint} endpoint)`);
            }
        }

        // Initialize stats display
        updateStats();
    </script>
</body>
</html>
