<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demo 4: Stream Elaboration</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f2f5;
            min-height: 100vh;
        }

        .header {
            background: linear-gradient(135deg, #38b2ac 0%, #319795 100%);
            color: white;
            padding: 20px 40px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 8px;
        }

        .header p {
            font-size: 14px;
            opacity: 0.9;
        }

        .container {
            display: flex;
            height: calc(100vh - 100px);
        }

        .main-content {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
        }

        .sidebar {
            width: 450px;
            background: white;
            border-left: 1px solid #e5e7eb;
            display: flex;
            flex-direction: column;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #e5e7eb;
        }

        .sidebar-header h2 {
            font-size: 18px;
            color: #333;
            margin-bottom: 10px;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #1a202c;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .config-panel {
            background: white;
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .config-panel h2 {
            margin-bottom: 20px;
            color: #333;
            font-size: 20px;
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-group label {
            margin-bottom: 8px;
            font-weight: 500;
            color: #555;
            font-size: 14px;
        }

        .form-group input,
        .form-group select {
            padding: 10px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #38b2ac;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #38b2ac;
            color: white;
        }

        .btn-primary:hover {
            background: #319795;
        }

        .btn-primary:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #718096;
            color: white;
        }

        .btn-secondary:hover {
            background: #4a5568;
        }

        .status-bar {
            display: flex;
            gap: 20px;
            align-items: center;
            padding: 15px 20px;
            background: white;
            border-radius: 8px;
            margin-bottom: 30px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .status-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 500;
        }

        .status-badge.connected {
            background: #d4edda;
            color: #155724;
        }

        .status-badge.disconnected {
            background: #f8d7da;
            color: #721c24;
        }

        .stat {
            font-size: 13px;
            color: #6c757d;
        }

        .stat strong {
            color: #333;
            font-size: 16px;
            margin-left: 5px;
        }

        .log-entry {
            margin-bottom: 15px;
            padding: 12px;
            background: #2d3748;
            border-radius: 4px;
            border-left: 3px solid #38b2ac;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .log-entry.error {
            border-left-color: #f56565;
        }

        .log-entry.warning {
            border-left-color: #ed8936;
        }

        .log-timestamp {
            color: #718096;
            font-size: 11px;
            margin-bottom: 5px;
        }

        .log-title {
            color: #38b2ac;
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .log-content {
            color: #e2e8f0;
            line-height: 1.6;
        }

        .log-content .key {
            color: #81e6d9;
        }

        .log-content .value {
            color: #fbd38d;
        }

        .log-content .result {
            color: #9ae6b4;
            font-weight: bold;
        }

        .info-box {
            background: #e6fffa;
            border: 1px solid #81e6d9;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .info-box h3 {
            color: #234e52;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .info-box ul {
            margin-left: 20px;
            color: #2c7a7b;
            font-size: 14px;
        }

        .info-box li {
            margin-bottom: 5px;
        }

        small {
            color: #6c757d;
            font-size: 12px;
            display: block;
            margin-top: 4px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>‚öôÔ∏è Stream Elaboration Engine</h1>
        <p>Subscribe to measurements, fetch sensor metadata, and perform computations in real-time</p>
    </div>

    <div class="container">
        <div class="main-content">
            <!-- Info Box -->
            <div class="info-box">
                <h3>How It Works:</h3>
                <ul>
                    <li>Subscribe to a measurement type (e.g., power_generation, temperature)</li>
                    <li>When a measurement arrives, fetch sensor metadata from content API</li>
                    <li>Perform computation based on measurement + metadata</li>
                    <li>Results are logged in the sidebar</li>
                    <li>Example: Calculate energy efficiency, normalize by capacity, etc.</li>
                </ul>
            </div>

            <!-- Configuration Panel -->
            <div class="config-panel">
                <h2>Elaboration Configuration</h2>
                <div class="form-row">
                    <div class="form-group">
                        <label for="type-name">Measurement Type</label>
                        <input type="text" id="type-name" placeholder="e.g., power_generation" value="power_generation">
                        <small>The type to subscribe to</small>
                    </div>
                    <div class="form-group">
                        <label for="computation-type">Computation Type</label>
                        <select id="computation-type" onchange="updateComputationHelp()">
                            <option value="efficiency">‚ö° Efficiency Score - Compare value to sensor capacity</option>
                            <option value="anomaly">üîç Anomaly Detection - Find unusual values vs historical avg</option>
                            <option value="aggregate">üìä Aggregate Stats - Calculate sum, avg, min, max</option>
                            <option value="normalize">üìè Normalize - Scale values to 0-100 range</option>
                        </select>
                        <div id="computation-help" style="margin-top: 10px; padding: 10px; background: #f0f9ff; border-left: 3px solid #38b2ac; border-radius: 4px; font-size: 13px; color: #2c7a7b;">
                            <strong>‚ö° Efficiency:</strong> Calculates how efficiently a sensor is operating by comparing its current value to its rated capacity. Result: percentage score with quality rating.
                        </div>
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label for="dataset-filter">Dataset Filter (optional)</label>
                        <input type="text" id="dataset-filter" placeholder="e.g., solar_plants">
                        <small>Leave empty to process all sensors</small>
                    </div>
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="skip-snapshot" style="width: auto; margin-right: 8px;">
                            Skip Initial Snapshot
                        </label>
                    </div>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button class="btn btn-primary" id="btn-start" onclick="startElaboration()">Start Processing</button>
                    <button class="btn btn-secondary" id="btn-stop" onclick="stopElaboration()" disabled>Stop</button>
                    <button class="btn" onclick="clearLogs()" style="margin-left: auto;">Clear Logs</button>
                </div>
            </div>

            <!-- Status Bar -->
            <div class="status-bar">
                <span class="status-badge disconnected" id="status">‚ö´ Disconnected</span>
                <span class="stat">Processed: <strong id="stat-processed">0</strong></span>
                <span class="stat">Errors: <strong id="stat-errors">0</strong></span>
                <span class="stat">Avg Time: <strong id="stat-avg-time">--</strong></span>
            </div>
        </div>

        <!-- Log Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">
                <h2>üìã Processing Log</h2>
                <div class="stat">Real-time elaboration results</div>
            </div>
            <div class="sidebar-content" id="log-container">
                <div style="color: #718096; text-align: center; padding: 40px 20px;">
                    <p>Waiting for measurements...</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const WS_URL = 'ws://localhost:8080/api/v1/measurements/subscribe/advanced';
        const CONTENT_API_URL = 'http://localhost:8082/v1/Sensor';

        let ws = null;
        let processedCount = 0;
        let errorCount = 0;
        let processingTimes = [];
        let aggregateStats = {
            count: 0,
            sum: 0,
            values: []
        };

        function startElaboration() {
            const typeName = document.getElementById('type-name').value.trim();
            const computationType = document.getElementById('computation-type').value;
            const datasetFilter = document.getElementById('dataset-filter').value.trim();
            const skipSnapshot = document.getElementById('skip-snapshot').checked;

            if (!typeName) {
                alert('Please enter a measurement type');
                return;
            }

            document.getElementById('btn-start').disabled = true;
            document.getElementById('btn-stop').disabled = false;

            updateStatus('connecting');
            addLog('info', 'System', `Starting elaboration for type: ${typeName}, computation: ${computationType}`);

            ws = new WebSocket(WS_URL);

            ws.onopen = () => {
                const payload = {
                    timeseries_filter: {
                        required_types: [typeName]
                    },
                    measurement_filter: {
                        latest_only: true
                    },
                    skip_initial_snapshot: skipSnapshot,
                    limit: 100
                };

                if (datasetFilter) {
                    payload.timeseries_filter.dataset_ids = [datasetFilter];
                }

                const initMessage = {
                    type: 'connection_init',
                    payload: payload
                };

                ws.send(JSON.stringify(initMessage));
                console.log('Sent connection_init:', initMessage);
            };

            ws.onmessage = (event) => {
                const message = JSON.parse(event.data);

                if (message.type === 'connection_ack') {
                    updateStatus('connected');
                    addLog('info', 'System', 'Connected and subscribed successfully');
                } else if (message.type === 'data') {
                    processMeasurement(message.payload, computationType);
                } else if (message.type === 'error') {
                    console.error('WebSocket error:', message.payload);
                    addLog('error', 'Error', JSON.stringify(message.payload));
                    stopElaboration();
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateStatus('error');
                addLog('error', 'Connection Error', error.toString());
            };

            ws.onclose = () => {
                updateStatus('disconnected');
                addLog('info', 'System', 'Connection closed');
                document.getElementById('btn-start').disabled = false;
                document.getElementById('btn-stop').disabled = true;
            };
        }

        function stopElaboration() {
            if (ws) {
                ws.close();
                ws = null;
            }
        }

        async function processMeasurement(update, computationType) {
            const startTime = Date.now();

            try {
                const sensorId = update.sensor_name;
                const sensorName = update.sensor_name;
                const typeName = update.type_name;
                const value = update.value;
                const timestamp = update.timestamp;

                // Only process numeric values
                if (typeof value !== 'number') {
                    return;
                }

                // Fetch sensor metadata from content API
                const sensorInfo = await fetchSensorInfo(sensorId);

                // Perform computation
                let result;
                switch (computationType) {
                    case 'efficiency':
                        result = computeEfficiency(value, sensorInfo);
                        break;
                    case 'anomaly':
                        result = computeAnomaly(value, sensorInfo);
                        break;
                    case 'aggregate':
                        result = computeAggregate(value, sensorInfo);
                        break;
                    case 'normalize':
                        result = computeNormalize(value, sensorInfo);
                        break;
                    default:
                        result = { error: 'Unknown computation type' };
                }

                const processingTime = Date.now() - startTime;
                processingTimes.push(processingTime);
                if (processingTimes.length > 50) processingTimes.shift();

                processedCount++;
                updateStats();

                // Log the result
                logResult(sensorName, typeName, value, sensorInfo, result, processingTime);

            } catch (error) {
                errorCount++;
                updateStats();
                addLog('error', 'Processing Error', error.message);
            }
        }

        async function fetchSensorInfo(sensorId) {
            const response = await fetch(`${CONTENT_API_URL}/${sensorId}`);
            if (!response.ok) {
                throw new Error(`Failed to fetch sensor info: ${response.statusText}`);
            }
            return await response.json();
        }

        function computeEfficiency(value, sensorInfo) {
            // Mock: Calculate efficiency as value / capacity
            const capacity = sensorInfo.metadata?.capacity || sensorInfo.metadata?.max_capacity || 1000;
            const efficiency = (value / capacity) * 100;

            return {
                type: 'Efficiency Score',
                capacity: capacity,
                efficiency: efficiency.toFixed(2) + '%',
                rating: efficiency > 80 ? 'üü¢ Excellent' :
                       efficiency > 60 ? 'üü° Good' :
                       efficiency > 40 ? 'üü† Fair' : 'üî¥ Poor'
            };
        }

        function computeAnomaly(value, sensorInfo) {
            // Mock: Detect anomaly based on historical average
            aggregateStats.values.push(value);
            if (aggregateStats.values.length > 100) aggregateStats.values.shift();

            const avg = aggregateStats.values.reduce((a, b) => a + b, 0) / aggregateStats.values.length;
            const deviation = Math.abs(value - avg);
            const percentDeviation = (deviation / avg) * 100;

            return {
                type: 'Anomaly Detection',
                currentValue: value.toFixed(2),
                average: avg.toFixed(2),
                deviation: percentDeviation.toFixed(2) + '%',
                status: percentDeviation > 50 ? 'üö® ANOMALY DETECTED' :
                       percentDeviation > 25 ? '‚ö†Ô∏è Warning' : '‚úÖ Normal'
            };
        }

        function computeAggregate(value, sensorInfo) {
            aggregateStats.count++;
            aggregateStats.sum += value;
            aggregateStats.values.push(value);
            if (aggregateStats.values.length > 100) aggregateStats.values.shift();

            const avg = aggregateStats.sum / aggregateStats.count;
            const min = Math.min(...aggregateStats.values);
            const max = Math.max(...aggregateStats.values);

            return {
                type: 'Aggregate Statistics',
                count: aggregateStats.count,
                sum: aggregateStats.sum.toFixed(2),
                avg: avg.toFixed(2),
                min: min.toFixed(2),
                max: max.toFixed(2)
            };
        }

        function computeNormalize(value, sensorInfo) {
            // Mock: Normalize to 0-100 scale based on sensor metadata
            const minVal = sensorInfo.metadata?.min_value || 0;
            const maxVal = sensorInfo.metadata?.max_value || 1000;
            const normalized = ((value - minVal) / (maxVal - minVal)) * 100;

            return {
                type: 'Normalized Value',
                originalValue: value.toFixed(2),
                range: `${minVal} - ${maxVal}`,
                normalized: Math.max(0, Math.min(100, normalized)).toFixed(2),
                percentile: normalized > 75 ? 'Top 25%' :
                           normalized > 50 ? 'Top 50%' :
                           normalized > 25 ? 'Bottom 50%' : 'Bottom 25%'
            };
        }

        function logResult(sensorName, typeName, value, sensorInfo, result, processingTime) {
            const timestamp = new Date().toLocaleTimeString();

            let content = `<div class="log-content">`;

            // Input Data Section
            content += `<div style="background: #1a202c; padding: 8px; border-radius: 4px; margin-bottom: 10px; border: 1px solid #4a5568;">`;
            content += `<div style="color: #cbd5e0; font-weight: bold; margin-bottom: 6px; font-size: 11px;">üì• INPUT DATA:</div>`;
            content += `<div><span class="key">Sensor:</span> <span class="value">${sensorName}</span></div>`;
            content += `<div><span class="key">Type:</span> <span class="value">${typeName}</span></div>`;
            content += `<div><span class="key">Measurement:</span> <span class="value" style="font-size: 16px; font-weight: bold;">${value.toFixed(2)}</span></div>`;
            content += `<div><span class="key">Dataset:</span> <span class="value">${sensorInfo.dataset_id || 'N/A'}</span></div>`;
            content += `</div>`;

            // Computation Result Section
            content += `<div style="background: #234e52; padding: 8px; border-radius: 4px; border: 2px solid #38b2ac;">`;
            content += `<div style="color: #81e6d9; font-weight: bold; margin-bottom: 6px; font-size: 11px;">üì§ COMPUTED RESULT:</div>`;

            for (const [key, val] of Object.entries(result)) {
                if (key !== 'type') {
                    const displayKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    content += `<div style="margin-bottom: 3px;"><span class="key">${displayKey}:</span> <span class="result" style="font-size: ${key.includes('status') || key.includes('rating') ? '14px' : '13px'};">${val}</span></div>`;
                }
            }

            content += `</div>`;

            // Processing Time Footer
            content += `<div style="margin-top: 8px; color: #718096; font-size: 11px; text-align: right;">‚è±Ô∏è Processed in ${processingTime}ms</div>`;
            content += `</div>`;

            addLog('info', result.type, content);
        }

        function addLog(level, title, content) {
            const container = document.getElementById('log-container');
            const timestamp = new Date().toLocaleTimeString();

            const entry = document.createElement('div');
            entry.className = `log-entry ${level}`;
            entry.innerHTML = `
                <div class="log-timestamp">[${timestamp}]</div>
                <div class="log-title">${title}</div>
                ${content}
            `;

            if (container.firstChild && container.firstChild.style) {
                container.insertBefore(entry, container.firstChild);
            } else {
                container.innerHTML = '';
                container.appendChild(entry);
            }

            // Keep only last 50 entries
            while (container.children.length > 50) {
                container.removeChild(container.lastChild);
            }
        }

        function clearLogs() {
            document.getElementById('log-container').innerHTML = `
                <div style="color: #718096; text-align: center; padding: 40px 20px;">
                    <p>Logs cleared. Waiting for measurements...</p>
                </div>
            `;
            processedCount = 0;
            errorCount = 0;
            processingTimes = [];
            aggregateStats = { count: 0, sum: 0, values: [] };
            updateStats();
        }

        function updateStats() {
            document.getElementById('stat-processed').textContent = processedCount;
            document.getElementById('stat-errors').textContent = errorCount;

            if (processingTimes.length > 0) {
                const avgTime = processingTimes.reduce((a, b) => a + b, 0) / processingTimes.length;
                document.getElementById('stat-avg-time').textContent = avgTime.toFixed(0) + 'ms';
            }
        }

        function updateStatus(status) {
            const statusEl = document.getElementById('status');

            if (status === 'connected') {
                statusEl.className = 'status-badge connected';
                statusEl.textContent = 'üü¢ Connected';
            } else if (status === 'connecting') {
                statusEl.className = 'status-badge';
                statusEl.style.background = '#fff3cd';
                statusEl.style.color = '#856404';
                statusEl.textContent = 'üü° Connecting...';
            } else {
                statusEl.className = 'status-badge disconnected';
                statusEl.textContent = '‚ö´ Disconnected';
            }
        }

        function updateComputationHelp() {
            const type = document.getElementById('computation-type').value;
            const helpEl = document.getElementById('computation-help');

            const helpText = {
                efficiency: '<strong>‚ö° Efficiency:</strong> Calculates how efficiently a sensor is operating by comparing its current value to its rated capacity.<br><em>Example: 450W / 1000W capacity = 45% efficiency ‚Üí "Fair" rating</em>',
                anomaly: '<strong>üîç Anomaly Detection:</strong> Compares current value to historical average to detect unusual readings.<br><em>Example: Current 850, Avg 500 ‚Üí 70% deviation ‚Üí "ANOMALY DETECTED"</em>',
                aggregate: '<strong>üìä Aggregate Stats:</strong> Maintains running statistics across all measurements received.<br><em>Example: Shows count, sum, average, min, and max of all values processed</em>',
                normalize: '<strong>üìè Normalize:</strong> Scales values to a standard 0-100 range based on sensor min/max.<br><em>Example: 750 in range 0-1000 ‚Üí 75 (Top 25% percentile)</em>'
            };

            helpEl.innerHTML = helpText[type];
        }

        // Initialize help text on page load
        updateComputationHelp();
    </script>
</body>
</html>
