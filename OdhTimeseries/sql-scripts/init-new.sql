create schema if not exists intimev3;

-- =================================================================================
-- The PROVENANCE table remains from the original schema for data lineage.
-- It is the single source of truth for the origin of data.
-- =================================================================================
CREATE TABLE intimev3.provenance (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    uuid UUID NOT NULL UNIQUE,
    lineage VARCHAR(255) NOT NULL,
    data_collector VARCHAR(255) NOT NULL,
    data_collector_version VARCHAR(255) NULL,
    CONSTRAINT uc_provenance_lineage_collector UNIQUE (lineage, data_collector, data_collector_version)
);

COMMENT ON TABLE intimev3.provenance IS 'Stores metadata about the origin and lineage of a measurement.';
COMMENT ON COLUMN intimev3.provenance.uuid IS 'A UUID for external referencing of the provenance record.';
COMMENT ON COLUMN intimev3.provenance.lineage IS 'The source system or process from which the data was collected.';

-- =================================================================================
-- The SENSORS table (renamed from 'station') stores information about the physical
-- or logical sensors. The JSONB column consolidates metadata.
-- =================================================================================
CREATE TABLE intimev3.sensors (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL UNIQUE,
    parent_id BIGINT NULL,
    metadata JSONB NULL,
    created_on TIMESTAMPTZ NOT NULL DEFAULT now(),
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    is_available BOOLEAN NOT NULL DEFAULT TRUE,
    CONSTRAINT fk_sensor_parent_id FOREIGN KEY (parent_id) REFERENCES intimev3.sensors(id)
);

CREATE INDEX idx_sensor_parent_id ON intimev3.sensors (parent_id);

COMMENT ON TABLE intimev3.sensors IS 'Represents individual sensors or stations. Consolidates metadata into a single JSONB column.';
COMMENT ON COLUMN intimev3.sensors.metadata IS 'A flexible JSONB column for any unstructured sensor-specific metadata.';

-- =================================================================================
-- The UNITS table stores all possible measurement units and their data types.
-- This table is a dictionary for all timeseries, enforcing consistency.
-- =================================================================================
CREATE TABLE intimev3."types" (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL UNIQUE,
    description VARCHAR(255) NULL,
    unit VARCHAR(255) NULL,
    -- This column explicitly stores the type of data, which informs which
    -- partitioned measurement table to use.
    data_type VARCHAR(50) NOT NULL CHECK (data_type IN ('numeric', 'string', 'geoposition', 'json', 'boolean', 'geoshape')),
    metadata JSONB NULL
);

COMMENT ON TABLE intimev3."types" IS 'A dictionary table for all measurement units and their corresponding data types.';
COMMENT ON COLUMN intimev3."types".data_type IS 'The data type of the measurements for this unit (e.g., numeric, string, geoposition).';

-- =================================================================================
-- The DATASETS table defines collections of timeseries types.
-- =================================================================================
CREATE TABLE intimev3.datasets (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL UNIQUE,
    description VARCHAR(255) NULL,
    created_on TIMESTAMPTZ NOT NULL DEFAULT now()
);

COMMENT ON TABLE intimev3.datasets IS 'A collection of timeseries, grouping them by a common semantic purpose.';

-- =================================================================================
-- Junction table for many-to-many relationship between datasets and types
-- =================================================================================
CREATE TABLE intimev3.dataset_types (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    dataset_id UUID NOT NULL,
    type_id BIGINT NOT NULL,
    is_required BOOLEAN NOT NULL DEFAULT true,
    created_on TIMESTAMPTZ NOT NULL DEFAULT now(),
    CONSTRAINT uc_dataset_type UNIQUE (dataset_id, type_id),
    CONSTRAINT fk_dataset_types_dataset FOREIGN KEY (dataset_id) REFERENCES intimev3.datasets(id) ON DELETE CASCADE,
    CONSTRAINT fk_dataset_types_type FOREIGN KEY (type_id) REFERENCES intimev3.types(id) ON DELETE CASCADE
);

CREATE INDEX idx_dataset_types_dataset_id ON intimev3.dataset_types (dataset_id);
CREATE INDEX idx_dataset_types_type_id ON intimev3.dataset_types (type_id);

COMMENT ON TABLE intimev3.dataset_types IS 'Many-to-many relationship between datasets and types, defining which types belong to each dataset.';
COMMENT ON COLUMN intimev3.dataset_types.is_required IS 'Whether this type is required for a timeseries to be part of this dataset.';

-- =================================================================================
-- The TIMESERIES table defines the unique data streams for each sensor.
-- It now references the TYPES table and the new DATASETS table.
-- =================================================================================
CREATE TABLE intimev3.timeseries (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    sensor_id BIGINT NOT NULL,
    type_id BIGINT NOT NULL,
    created_on TIMESTAMPTZ NOT NULL DEFAULT now(),
    CONSTRAINT uc_timeseries_sensor_type_dataset UNIQUE (sensor_id, type_id),
    CONSTRAINT fk_timeseries_sensor FOREIGN KEY (sensor_id) REFERENCES intimev3.sensors(id) ON DELETE CASCADE,
    CONSTRAINT fk_timeseries_type FOREIGN KEY (type_id) REFERENCES intimev3.types(id) ON DELETE RESTRICT
);

CREATE INDEX idx_timeseries_sensor_id ON intimev3.timeseries (sensor_id);

COMMENT ON TABLE intimev3.timeseries IS 'Defines a unique data stream for a sensor. Holds metadata and a reference to the unit and dataset.';
COMMENT ON COLUMN intimev3.timeseries.type_id IS 'Foreign key to the types table, linking this timeseries to its unit and data type.';

-- =================================================================================
-- Partitioned Measurement Tables for different data types.
-- These tables remain unchanged as the core of the measurement storage.
-- =================================================================================
CREATE TABLE intimev3.measurements_numeric (
    timeseries_id UUID NOT NULL,
    timestamp TIMESTAMPTZ NOT NULL,
    value FLOAT8 NOT NULL,
    provenance_id BIGINT NULL,
    created_on TIMESTAMPTZ NOT NULL DEFAULT now()
) PARTITION BY HASH (timeseries_id);

CREATE TABLE intimev3.measurements_string (
    timeseries_id UUID NOT NULL,
    timestamp TIMESTAMPTZ NOT NULL,
    value VARCHAR(255) NOT NULL,
    provenance_id BIGINT NULL,
    created_on TIMESTAMPTZ NOT NULL DEFAULT now()
) PARTITION BY HASH (timeseries_id);

CREATE TABLE intimev3.measurements_json (
    timeseries_id UUID NOT NULL,
    timestamp TIMESTAMPTZ NOT NULL,
    value JSONB NOT NULL,
    provenance_id BIGINT NULL,
    created_on TIMESTAMPTZ NOT NULL DEFAULT now()
) PARTITION BY HASH (timeseries_id);

CREATE TABLE intimev3.measurements_geoposition (
    timeseries_id UUID NOT NULL,
    timestamp TIMESTAMPTZ NOT NULL,
    value public.geometry(Point, 4326) NOT NULL,
    provenance_id BIGINT NULL,
    created_on TIMESTAMPTZ NOT NULL DEFAULT now()
) PARTITION BY HASH (timeseries_id);

CREATE TABLE intimev3.measurements_geoshape (
    timeseries_id UUID NOT NULL,
    timestamp TIMESTAMPTZ NOT NULL,
    value public.geometry(Polygon, 4326) NOT NULL,
    provenance_id BIGINT NULL,
    created_on TIMESTAMPTZ NOT NULL DEFAULT now()
) PARTITION BY HASH (timeseries_id);

CREATE TABLE intimev3.measurements_boolean (
    timeseries_id UUID NOT NULL,
    timestamp TIMESTAMPTZ NOT NULL,
    value BOOLEAN NOT NULL,
    provenance_id BIGINT NULL,
    created_on TIMESTAMPTZ NOT NULL DEFAULT now()
) PARTITION BY HASH (timeseries_id);

CREATE INDEX idx_numeric_timestamp ON intimev3.measurements_numeric (timestamp DESC);
CREATE INDEX idx_string_timestamp ON intimev3.measurements_string (timestamp DESC);
CREATE INDEX idx_json_timestamp ON intimev3.measurements_json (timestamp DESC);
CREATE INDEX idx_geoposition_timestamp ON intimev3.measurements_geoposition (timestamp DESC);
CREATE INDEX idx_geoshape_timestamp ON intimev3.measurements_geoshape (timestamp DESC);
CREATE INDEX idx_boolean_timestamp ON intimev3.measurements_boolean (timestamp DESC);

-- =================================================================================
-- Partition Creation and Indexing
-- In a time-based partitioning scheme, you'll need a script to regularly create
-- new partitions for future data. These examples show how to create a yearly
-- partition.
-- =================================================================================

-- -- Example: Creating partitions for numeric data for the year 2025
-- CREATE TABLE intimev3.measurements_numeric_2025 PARTITION OF intimev3.measurements_numeric
--     FOR VALUES FROM ('2025-01-01 00:00:00+00') TO ('2026-01-01 00:00:00+00');
-- ALTER TABLE intimev3.measurements_numeric_2025 ADD PRIMARY KEY (timeseries_id, timestamp);
-- CREATE INDEX idx_numeric_timestamp_2025 ON intimev3.measurements_numeric_2025 (timestamp DESC);
-- CREATE INDEX idx_numeric_timeseries_id_2025 ON intimev3.measurements_numeric_2025 (timeseries_id);

-- -- Example: Creating partitions for string data for the year 2025
-- CREATE TABLE intimev3.measurements_string_2025 PARTITION OF intimev3.measurements_string
--     FOR VALUES FROM ('2025-01-01 00:00:00+00') TO ('2026-01-01 00:00:00+00');
-- ALTER TABLE intimev3.measurements_string_2025 ADD PRIMARY KEY (timeseries_id, timestamp);
-- CREATE INDEX idx_string_timestamp_2025 ON intimev3.measurements_string_2025 (timestamp DESC);
-- CREATE INDEX idx_string_timeseries_id_2025 ON intimev3.measurements_string_2025 (timeseries_id);

-- -- Example: Creating partitions for JSON data for the year 2025
-- CREATE TABLE intimev3.measurements_json_2025 PARTITION OF intimev3.measurements_json
--     FOR VALUES FROM ('2025-01-01 00:00:00+00') TO ('2026-01-01 00:00:00+00');
-- ALTER TABLE intimev3.measurements_json_2025 ADD PRIMARY KEY (timeseries_id, timestamp);
-- CREATE INDEX idx_json_timestamp_2025 ON intimev3.measurements_json_2025 (timestamp DESC);
-- CREATE INDEX idx_json_timeseries_id_2025 ON intimev3.measurements_json_2025 (timeseries_id);

-- -- Example: Creating partitions for geospatial point data for the year 2025
-- CREATE TABLE intimev3.measurements_geoposition_2025 PARTITION OF intimev3.measurements_geoposition
--     FOR VALUES FROM ('2025-01-01 00:00:00+00') TO ('2026-01-01 00:00:00+00');
-- ALTER TABLE intimev3.measurements_geoposition_2025 ADD PRIMARY KEY (timeseries_id, timestamp);
-- CREATE INDEX idx_geoposition_timestamp_2025 ON intimev3.measurements_geoposition_2025 (timestamp DESC);
-- CREATE INDEX idx_geoposition_timeseries_id_2025 ON intimev3.measurements_geoposition_2025 (timeseries_id);
-- CREATE INDEX idx_geoposition_value_2025 ON intimev3.measurements_geoposition_2025 USING GIST (value);

-- -- Example: Creating partitions for geospatial shape data for the year 2025
-- CREATE TABLE intimev3.measurements_geoshape_2025 PARTITION OF intimev3.measurements_geoshape
--     FOR VALUES FROM ('2025-01-01 00:00:00+00') TO ('2026-01-01 00:00:00+00');
-- ALTER TABLE intimev3.measurements_geoshape_2025 ADD PRIMARY KEY (timeseries_id, timestamp);
-- CREATE INDEX idx_geoshape_timestamp_2025 ON intimev3.measurements_geoshape_2025 (timestamp DESC);
-- CREATE INDEX idx_geoshape_timeseries_id_2025 ON intimev3.measurements_geoshape_2025 (timeseries_id);
-- CREATE INDEX idx_geoshape_value_2025 ON intimev3.measurements_geoshape_2025 USING GIST (value);

-- -- Example: Creating partitions for boolean data for the year 2025
-- CREATE TABLE intimev3.measurements_boolean_2025 PARTITION OF intimev3.measurements_boolean
--     FOR VALUES FROM ('2025-01-01 00:00:00+00') TO ('2026-01-01 00:00:00+00');
-- ALTER TABLE intimev3.measurements_boolean_2025 ADD PRIMARY KEY (timeseries_id, timestamp);
-- CREATE INDEX idx_boolean_timestamp_2025 ON intimev3.measurements_boolean_2025 (timestamp DESC);
-- CREATE INDEX idx_boolean_timeseries_id_2025 ON intimev3.measurements_boolean_2025 (timeseries_id);